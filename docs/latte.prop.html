<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>latte.prop documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Latte</span> <span class="project-version">0.3.5-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="00_overview.html"><div class="inner"><span>Overview</span></div></a></li><li class="depth-1 "><a href="01_intro.html"><div class="inner"><span>Introduction to latte</span></div></a></li><li class="depth-1 "><a href="101_A_logician_dream.html"><div class="inner"><span>A Logician's Dream</span></div></a></li><li class="depth-1 "><a href="102_Lambda_the_ultimate.html"><div class="inner"><span>Lambda the ultimate</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>latte</span></div></div></li><li class="depth-2 branch"><a href="latte.classic.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>classic</span></div></a></li><li class="depth-2 branch"><a href="latte.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="latte.equal.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>equal</span></div></a></li><li class="depth-2 branch current"><a href="latte.prop.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>prop</span></div></a></li><li class="depth-2 branch"><a href="latte.quant.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>quant</span></div></a></li><li class="depth-2"><a href="latte.rel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rel</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="latte.prop.html#var-.25and-elim-left"><div class="inner"><span>%and-elim-left</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-.25and-elim-right"><div class="inner"><span>%and-elim-right</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-.25and-intro"><div class="inner"><span>%and-intro</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-.3C.3D.3E"><div class="inner"><span>&lt;=&gt;</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-absurd"><div class="inner"><span>absurd</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-absurd-intro"><div class="inner"><span>absurd-intro</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-and"><div class="inner"><span>and</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-and-elim-left"><div class="inner"><span>and-elim-left</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-and-elim-right"><div class="inner"><span>and-elim-right</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-and-intro"><div class="inner"><span>and-intro</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-and-sym"><div class="inner"><span>and-sym</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-decompose-and-type"><div class="inner"><span>decompose-and-type</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-ex-falso"><div class="inner"><span>ex-falso</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-iff-elim-if"><div class="inner"><span>iff-elim-if</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-iff-elim-only-if"><div class="inner"><span>iff-elim-only-if</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-iff-intro"><div class="inner"><span>iff-intro</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-iff-refl"><div class="inner"><span>iff-refl</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-iff-sym"><div class="inner"><span>iff-sym</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-iff-trans"><div class="inner"><span>iff-trans</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-impl-ignore"><div class="inner"><span>impl-ignore</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-impl-not-not"><div class="inner"><span>impl-not-not</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-impl-refl"><div class="inner"><span>impl-refl</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-impl-trans"><div class="inner"><span>impl-trans</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-not"><div class="inner"><span>not</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-or"><div class="inner"><span>or</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-or-elim"><div class="inner"><span>or-elim</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-or-intro-left"><div class="inner"><span>or-intro-left</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-or-intro-right"><div class="inner"><span>or-intro-right</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-or-not-impl-elim"><div class="inner"><span>or-not-impl-elim</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-or-sym"><div class="inner"><span>or-sym</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-truth"><div class="inner"><span>truth</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-truth-is-true"><div class="inner"><span>truth-is-true</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">latte.prop</h1><div class="doc"><div class="markdown"><p>Basic definitions and theorems for (intuitionistic) propositional logic. Most natural deduction rules are provided as theorems in this namespace.</p></div></div><div class="public anchor" id="var-.25and-elim-left"><h3>%and-elim-left</h3><div class="usage"><code>(%and-elim-left and-term)</code></div><div class="doc"><div class="markdown"><p>A special elimination rule that takes a proof of type <code>(and A B)</code> and yields a proof of <code>A</code>.</p>
<p>This is a special version of <a href="latte.prop.html#var-and-elim-left">and-elim-left</a>.</p></div></div></div><div class="public anchor" id="var-.25and-elim-right"><h3>%and-elim-right</h3><div class="usage"><code>(%and-elim-right and-term)</code></div><div class="doc"><div class="markdown"><p>A special elimination rule that takes a proof of type <code>(and A B)</code> and yields a proof of <code>B</code>.</p>
<p>This is a special version of <a href="latte.prop.html#var-and-elim-right">and-elim-right</a>.</p></div></div></div><div class="public anchor" id="var-.25and-intro"><h3>%and-intro</h3><div class="usage"><code>(%and-intro a b)</code></div><div class="doc"><div class="markdown"><p>A special introduction rule that takes a proof <code>a</code> of type <code>A</code>, a proof <code>b</code> of type <code>B</code> and yields a proof of type <code>(and A B)</code>.</p>
<p>This is a special version of <a href="latte.prop.html#var-and-intro">and-intro</a>.</p></div></div></div><div class="public anchor" id="var-.3C.3D.3E"><h3>&lt;=&gt;</h3><div class="usage"><code>(&lt;=&gt; [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(and (==&gt; A B) (==&gt; B A))
</code></pre>
<p><strong>Definition</strong></p>
<p>Logical equivalence or ‘if and only if’.</p></div></div></div><div class="public anchor" id="var-absurd"><h3>absurd</h3><div class="usage"><code>(absurd)</code></div><div class="doc"><div class="markdown"><pre><code>(forall [α :type] α)
</code></pre>
<p><strong>Definition</strong></p>
<p>Absurdity.</p></div></div></div><div class="public anchor" id="var-absurd-intro"><h3>absurd-intro</h3><div class="usage"><code>(absurd-intro [A :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; A (not A) absurd)
</code></pre>
<p><strong>Theorem</strong></p>
<p>Introduction rule for absurdity.</p></div></div></div><div class="public anchor" id="var-and"><h3>and</h3><div class="usage"><code>(and [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [C :type] (==&gt; (==&gt; A B C) C))
</code></pre>
<p><strong>Definition</strong></p>
<p>logical conjunction.</p></div></div></div><div class="public anchor" id="var-and-elim-left"><h3>and-elim-left</h3><div class="usage"><code>(and-elim-left [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (and A B) A)
</code></pre>
<p><strong>Theorem</strong></p>
<p>Elimination rule for logical conjunction.  This one only keeps the left-side of the conjunction</p></div></div></div><div class="public anchor" id="var-and-elim-right"><h3>and-elim-right</h3><div class="usage"><code>(and-elim-right [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (and A B) B)
</code></pre>
<p><strong>Theorem</strong></p>
<p>Elimination rule for logical conjunction.  This one only keeps the right-side of the conjunction</p></div></div></div><div class="public anchor" id="var-and-intro"><h3>and-intro</h3><div class="usage"><code>(and-intro [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; A B (and A B))
</code></pre>
<p><strong>Theorem</strong></p>
<p>Introduction rule for logical conjunction.</p></div></div></div><div class="public anchor" id="var-and-sym"><h3>and-sym</h3><div class="usage"><code>(and-sym [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (and A B) (and B A))
</code></pre>
<p><strong>Theorem</strong></p>
<p>Symmetry of conjunction.</p></div></div></div><div class="public anchor" id="var-decompose-and-type"><h3>decompose-and-type</h3><div class="usage"><code>(decompose-and-type def-env ctx t)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-ex-falso"><h3>ex-falso</h3><div class="usage"><code>(ex-falso [A :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; absurd A)
</code></pre>
<p><strong>Theorem</strong></p>
<p>Ex falso sequitur quodlibet  (proof by contradiction, elimination for absurdity).</p></div></div></div><div class="public anchor" id="var-iff-elim-if"><h3>iff-elim-if</h3><div class="usage"><code>(iff-elim-if [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (&lt;=&gt; A B) (==&gt; A B))
</code></pre>
<p><strong>Theorem</strong></p>
<p>Elimination rule for logical equivalence.  This one only keeps the if part of the equivalence.</p></div></div></div><div class="public anchor" id="var-iff-elim-only-if"><h3>iff-elim-only-if</h3><div class="usage"><code>(iff-elim-only-if [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (&lt;=&gt; A B) (==&gt; B A))
</code></pre>
<p><strong>Theorem</strong></p>
<p>Elimination rule for logical equivalence.  This one only keeps the only-if part of the equivalence.</p></div></div></div><div class="public anchor" id="var-iff-intro"><h3>iff-intro</h3><div class="usage"><code>(iff-intro [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (==&gt; A B) (==&gt; B A) (&lt;=&gt; A B))
</code></pre>
<p><strong>Theorem</strong></p>
<p>Introduction rule for logical equivalence.</p></div></div></div><div class="public anchor" id="var-iff-refl"><h3>iff-refl</h3><div class="usage"><code>(iff-refl [A :type])</code></div><div class="doc"><div class="markdown"><pre><code>(&lt;=&gt; A A)
</code></pre>
<p><strong>Theorem</strong></p>
<p>Reflexivity of logical equivalence.</p></div></div></div><div class="public anchor" id="var-iff-sym"><h3>iff-sym</h3><div class="usage"><code>(iff-sym [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (&lt;=&gt; A B) (&lt;=&gt; B A))
</code></pre>
<p><strong>Theorem</strong></p>
<p>Symmetry of logical equivalence.</p></div></div></div><div class="public anchor" id="var-iff-trans"><h3>iff-trans</h3><div class="usage"><code>(iff-trans [A :type] [B :type] [C :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (&lt;=&gt; A B) (&lt;=&gt; B C) (&lt;=&gt; A C))
</code></pre>
<p><strong>Theorem</strong></p>
<p>Transitivity of logical equivalence.</p></div></div></div><div class="public anchor" id="var-impl-ignore"><h3>impl-ignore</h3><div class="usage"><code>(impl-ignore [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; A B A)
</code></pre>
<p><strong>Theorem</strong></p>
<p>A variant of reflexivity.</p></div></div></div><div class="public anchor" id="var-impl-not-not"><h3>impl-not-not</h3><div class="usage"><code>(impl-not-not [A :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; A (not (not A)))
</code></pre>
<p><strong>Theorem</strong></p>
<p>The if half of double negation.</p>
<p>This can be seen as an introduction rule for ¬¬ (not-not) propositions. Note that double-negation is a law of classical (non-intuitionistic) logic.</p></div></div></div><div class="public anchor" id="var-impl-refl"><h3>impl-refl</h3><div class="usage"><code>(impl-refl [A :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; A A)
</code></pre>
<p><strong>Theorem</strong></p>
<p>Implication is reflexive.</p></div></div></div><div class="public anchor" id="var-impl-trans"><h3>impl-trans</h3><div class="usage"><code>(impl-trans [A :type] [B :type] [C :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (==&gt; A B) (==&gt; B C) (==&gt; A C))
</code></pre>
<p><strong>Theorem</strong></p>
<p>Implication is transitive.</p></div></div></div><div class="public anchor" id="var-not"><h3>not</h3><div class="usage"><code>(not [A :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; A absurd)
</code></pre>
<p><strong>Definition</strong></p>
<p>Logical negation.</p></div></div></div><div class="public anchor" id="var-or"><h3>or</h3><div class="usage"><code>(or [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [C :type] (==&gt; (==&gt; A C) (==&gt; B C) C))
</code></pre>
<p><strong>Definition</strong></p>
<p>logical disjunction.</p></div></div></div><div class="public anchor" id="var-or-elim"><h3>or-elim</h3><div class="usage"><code>(or-elim [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (or A B) (forall [C :type] (==&gt; (==&gt; A C) (==&gt; B C) C)))
</code></pre>
<p><strong>Theorem</strong></p>
<p>Elimination rule for logical disjunction.</p>
<p>Remark: this rule is not very useful since it only reflects the definition of <code>or</code>. This is unlike for classical logic, which offers a much simpler elimination process.</p></div></div></div><div class="public anchor" id="var-or-intro-left"><h3>or-intro-left</h3><div class="usage"><code>(or-intro-left [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; A (or A B))
</code></pre>
<p><strong>Theorem</strong></p>
<p>Introduction rule for logical disjunction. This is the introduction by the left operand.</p></div></div></div><div class="public anchor" id="var-or-intro-right"><h3>or-intro-right</h3><div class="usage"><code>(or-intro-right [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; B (or A B))
</code></pre>
<p><strong>Theorem</strong></p>
<p>Introduction rule for logical disjunction. This is the introduction by the right operand.</p></div></div></div><div class="public anchor" id="var-or-not-impl-elim"><h3>or-not-impl-elim</h3><div class="usage"><code>(or-not-impl-elim [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (or A B) (==&gt; (not A) B))
</code></pre>
<p><strong>Theorem</strong></p>
<p>An alternative elimination rule for disjunction.</p></div></div></div><div class="public anchor" id="var-or-sym"><h3>or-sym</h3><div class="usage"><code>(or-sym [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (or A B) (or B A))
</code></pre>
<p><strong>Theorem</strong></p>
<p>Symmetry of disjunction.</p>
<p>Remark: the proof for this theorem illustrates the non-trivial characteristic of or-elimination.</p></div></div></div><div class="public anchor" id="var-truth"><h3>truth</h3><div class="usage"><code>(truth)</code></div><div class="doc"><div class="markdown"><pre><code>(not absurd)
</code></pre>
<p><strong>Definition</strong></p>
<p>Logical truth.</p></div></div></div><div class="public anchor" id="var-truth-is-true"><h3>truth-is-true</h3><div class="usage"><code>(truth-is-true)</code></div><div class="doc"><div class="markdown"><pre><code>truth
</code></pre>
<p><strong>Theorem</strong></p>
<p>The truth is true (really ?).</p></div></div></div></div></body></html>