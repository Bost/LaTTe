<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>latte.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Latte</span> <span class="project-version">0.99.7-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="00_overview.html"><div class="inner"><span>Overview</span></div></a></li><li class="depth-1 "><a href="01_intro.html"><div class="inner"><span>Introduction to latte</span></div></a></li><li class="depth-1 "><a href="101_A_logician_dream.html"><div class="inner"><span>A Logician's Dream</span></div></a></li><li class="depth-1 "><a href="102_Lambda_the_ultimate.html"><div class="inner"><span>Lambda the ultimate</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>latte</span></div></div></li><li class="depth-2 branch"><a href="latte.classic.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>classic</span></div></a></li><li class="depth-2 branch current"><a href="latte.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="latte.equal.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>equal</span></div></a></li><li class="depth-2 branch"><a href="latte.fun.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fun</span></div></a></li><li class="depth-2 branch"><a href="latte.prop.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>prop</span></div></a></li><li class="depth-2"><a href="latte.quant.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>quant</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="latte.core.html#var-assume"><div class="inner"><span>assume</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-defaxiom"><div class="inner"><span>defaxiom</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-defimplicit"><div class="inner"><span>defimplicit</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-defimplicit*"><div class="inner"><span>defimplicit*</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-definition"><div class="inner"><span>definition</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-deflemma"><div class="inner"><span>deflemma</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-defnotation"><div class="inner"><span>defnotation</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-defthm"><div class="inner"><span>defthm</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-example"><div class="inner"><span>example</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-forall"><div class="inner"><span>forall</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-handle-ax-declaration"><div class="inner"><span>handle-ax-declaration</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-handle-defaxiom"><div class="inner"><span>handle-defaxiom</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-handle-defthm"><div class="inner"><span>handle-defthm</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-handle-example-thm"><div class="inner"><span>handle-example-thm</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-handle-term-definition"><div class="inner"><span>handle-term-definition</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-handle-thm-declaration"><div class="inner"><span>handle-thm-declaration</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-have"><div class="inner"><span>have</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-lambda"><div class="inner"><span>lambda</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-mk-def-doc"><div class="inner"><span>mk-def-doc</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-mk-impl-doc"><div class="inner"><span>mk-impl-doc</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-parse-parameters"><div class="inner"><span>parse-parameters</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-pose"><div class="inner"><span>pose</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-proof"><div class="inner"><span>proof</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-qed"><div class="inner"><span>qed</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-try-proof"><div class="inner"><span>try-proof</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">latte.core</h1><div class="doc"><div class="markdown"><p>This namespace provides the top-level forms of the LaTTe framework.</p></div></div><div class="public anchor" id="var-assume"><h3>assume</h3><h4 class="type">macro</h4><div class="usage"><code>(assume params &amp; body)</code></div><div class="doc"><div class="markdown"><p>An assume step of the form <code>(assume [x1 T1 x2 T2 ...] &lt;body&gt;)</code>.</p></div></div></div><div class="public anchor" id="var-defaxiom"><h3>defaxiom</h3><h4 class="type">macro</h4><div class="usage"><code>(defaxiom &amp; args)</code></div><div class="doc"><div class="markdown"><p>Declaration of an axiom with the specified <code>name</code> (first argument)  an optional <code>docstring</code> (second argument), a vector of <code>parameters</code>  and the axiom statement (last argument).  Each parameter is a pair <code>[x T]</code> with <code>x</code> the parameter name and <code>T</code> its  type. </p>
<p>An axiom is accepted without a proof, and should thus be used with extra care. The LaTTe rule of thumb is that theorems should be favored, but axioms are sometimes required (e.g. the law of the excluded  middle) or more “reasonable” because of the proof length or complexity. In all cases the introduction of an axiom must be justified with strong  (albeit informal) arguments.</p></div></div></div><div class="public anchor" id="var-defimplicit"><h3>defimplicit</h3><h4 class="type">macro</h4><div class="usage"><code>(defimplicit &amp; args)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-defimplicit*"><h3>defimplicit*</h3><h4 class="type">macro</h4><div class="usage"><code>(defimplicit* &amp; args)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-definition"><h3>definition</h3><h4 class="type">macro</h4><div class="usage"><code>(definition &amp; args)</code></div><div class="doc"><div class="markdown"><p>Defines a mathematical term composed of a <code>name</code>, and optional (but highly recommended) <code>docstring</code>, a vector of <code>parameters</code> and a <code>lambda-term</code> as definitional content.</p>
<p>An <code>ex-info</code> exception is thrown if the term cannot be defined.</p>
<p>Note that it is a Clojure <code>def</code>, the term is defined in the namespace where the <code>definition</code> form is invoked.</p></div></div></div><div class="public anchor" id="var-deflemma"><h3>deflemma</h3><h4 class="type">macro</h4><div class="usage"><code>(deflemma &amp; args)</code></div><div class="doc"><div class="markdown"><p>Declaration of a lemma, i.e. an auxiliary theorem. In LaTTe a lemma is private. To export a theorem the <a href="latte.core.html#var-defthm">defthm</a> form must be used instead.</p></div></div></div><div class="public anchor" id="var-defnotation"><h3>defnotation</h3><h4 class="type">macro</h4><div class="usage"><code>(defnotation &amp; args)</code></div><div class="doc"><div class="markdown"><p>Defines a new notation, which is a function called at parsing time. The result must be pair <code>[status u]</code>  with <code>status</code> either <code>:ok</code> (parsing successful) with <code>u</code> the term generated by the notation,  or <code>:ko</code> (parsing failed) and <code>u</code> is the error, a map with at least a key <code>:msg</code> explaining  the failure.</p>
<p>Be careful that the parser will be called recursively on the generated term, hence  recursive definitions must be handled with great care.</p></div></div></div><div class="public anchor" id="var-defthm"><h3>defthm</h3><h4 class="type">macro</h4><div class="usage"><code>(defthm &amp; args)</code></div><div class="doc"><div class="markdown"><p>Declaration of a theorem of the specified <code>name</code> (first argument)  an optional <code>docstring</code> (second argument), a vector of <code>parameters</code> and the theorem proposition (last argument). Each parameter is a pair <code>[x T]</code> with <code>x</code> the parameter name and <code>T</code> its  type. </p>
<p>A theorem declared must later on be demonstrated using the <a href="latte.core.html#var-proof">proof</a> form.</p></div></div></div><div class="public anchor" id="var-example"><h3>example</h3><h4 class="type">macro</h4><div class="usage"><code>(example &amp; args)</code></div><div class="doc"><div class="markdown"><p>An example of the form <code>(example T &lt;method&gt; &lt;steps&gt;)</code> is the statement of a proposition, as a type <code>T</code>, as well as a proof. The proof method is either <code>:script</code> (declarative proof script) or <code>:term</code> (proof term).</p></div></div></div><div class="public anchor" id="var-forall"><h3>forall</h3><div class="usage"><code>(forall params body)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-handle-ax-declaration"><h3>handle-ax-declaration</h3><div class="usage"><code>(handle-ax-declaration ax-name params ty)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-handle-defaxiom"><h3>handle-defaxiom</h3><div class="usage"><code>(handle-defaxiom kind ax-name doc params ty)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-handle-defthm"><h3>handle-defthm</h3><div class="usage"><code>(handle-defthm kind thm-name doc params ty)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-handle-example-thm"><h3>handle-example-thm</h3><div class="usage"><code>(handle-example-thm params ty)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-handle-term-definition"><h3>handle-term-definition</h3><div class="usage"><code>(handle-term-definition def-name params body)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-handle-thm-declaration"><h3>handle-thm-declaration</h3><div class="usage"><code>(handle-thm-declaration thm-name params ty)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-have"><h3>have</h3><h4 class="type">macro</h4><div class="usage"><code>(have have-name have-type by-kw have-term)</code></div><div class="doc"><div class="markdown"><p>A have step of the form <code>(have &lt;x&gt; T :by e)</code> checks that the  term <code>e</code> is of type <code>T</code>. If it is the case, then the fact is recorded  as a local definition named <code>&lt;x&gt;</code>. Otherwise an error is signaled. The type <code>T</code> can be replaced by <code>_</code> in which case is is inferred rather than checked. The name <code>&lt;x&gt;</code> can be replaced by <code>_</code> in which case no definition is recorded.</p></div></div></div><div class="public anchor" id="var-lambda"><h3>lambda</h3><div class="usage"><code>(lambda params body)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-mk-def-doc"><h3>mk-def-doc</h3><div class="usage"><code>(mk-def-doc kind content explanation)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-mk-impl-doc"><h3>mk-impl-doc</h3><div class="usage"><code>(mk-impl-doc name params explanation)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-parse-parameters"><h3>parse-parameters</h3><div class="usage"><code>(parse-parameters def-env params)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-pose"><h3>pose</h3><h4 class="type">macro</h4><div class="usage"><code>(pose pose-name pose-kw pose-term)</code></div><div class="doc"><div class="markdown"><p>A local definition <code>(pose P := e)</code> allows a proof to refer to term <code>e</code> under the name <code>P</code> in a proof. This is equivalent to <code>(have P _ :by e)</code> (with the type of <code>e</code> inferred).</p></div></div></div><div class="public anchor" id="var-proof"><h3>proof</h3><div class="usage"><code>(proof thm-name method &amp; steps)</code></div><div class="doc"><div class="markdown"><p>Provides a proof of theorem named <code>thm-name</code> using the given proof <code>method</code> and <code>steps</code>. There are for now two proof methods available:  - the <code>:term</code> method with one step: a direct proof/lambda-term  inhabiting the theorem/type (based on the proof-as-term, proposition-as-type  correspondances). This is a low-level proof method. </p>
<ul>
  <li>the <code>:script</code> method with a declarative proof script. It is a high-level (human-readable) proof method. A low-level proof term is synthetized from the script</li>
</ul></div></div></div><div class="public anchor" id="var-qed"><h3>qed</h3><h4 class="type">macro</h4><div class="usage"><code>(qed qed-term)</code></div><div class="doc"><div class="markdown"><p>A Qed step of the form <code>(qed e)</code> checks that the  term <code>e</code> allows to finish a proof in the current context. An error is signaled if the proof cannot be concluded.</p></div></div></div><div class="public anchor" id="var-try-proof"><h3>try-proof</h3><div class="usage"><code>(try-proof thm-name method &amp; steps)</code></div><div class="doc"><div class="markdown"><p>Provides a proof of theorem named <code>thm-name</code> using the given proof <code>method</code>  and <code>steps</code>.  There are for now two proof methods available:  - the <code>:term</code> method with one step: a direct proof/lambda-term  inhabiting the theorem/type (based on the proof-as-term, proposition-as-type  correspondances). This is a low-level proof method. </p>
<pre><code>- the `:script` method with a declarative proof script. It is a high-level
</code></pre>
<p>(human-readable) proof method. A low-level proof term is  synthetized from the script</p>
<p>This version only checks if the proof is correct or not, use the <a href="latte.core.html#var-proof">proof</a> function for actually registering the proof.</p></div></div></div></div></body></html>